<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D立方体模型 - 图片贴图旋转</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Microsoft YaHei', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 20px;
            overflow-x: hidden;
        }
        
        .container {
            text-align: center;
            max-width: 1200px;
            width: 100%;
        }
        
        h1 {
            color: white;
            font-size: 3rem;
            margin-bottom: 20px;
            text-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            font-weight: 300;
            letter-spacing: 2px;
        }
        
        .description {
            color: rgba(255, 255, 255, 0.9);
            font-size: 1.2rem;
            max-width: 800px;
            margin: 0 auto 50px;
            line-height: 1.8;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }
        
        .main-content {
            display: flex;
            flex-direction: column;
            gap: 30px;
            align-items: center;
        }
        
        .upload-section {
            background: rgba(255, 255, 255, 0.1);
            padding: 40px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 1100px;
        }
        
        .upload-title {
            color: white;
            font-size: 1.8rem;
            margin-bottom: 30px;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }
        
        .upload-form {
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
        }
        
        .file-input-group {
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 100%;
        }
        
        .file-label {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .file-label:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-2px);
        }
        
        .file-icon {
            font-size: 2rem;
            margin-bottom: 10px;
        }
        
        .file-text {
            color: white;
            font-size: 1rem;
            text-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        
        .file-input {
            display: none;
        }
        
        .upload-btn {
            background: linear-gradient(135deg, #00b894, #00a085);
            color: white;
            border: none;
            padding: 15px 40px;
            border-radius: 25px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 184, 148, 0.3);
            text-transform: uppercase;
            letter-spacing: 1px;
            width: 100%;
        }
        
        .upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 184, 148, 0.4);
        }
        
        .upload-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .preview-section {
            margin-top: 30px;
            display: none;
        }
        
        .preview-images {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .preview-label {
            color: white;
            font-size: 1rem;
            margin-bottom: 10px;
            text-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        
        .preview-image {
            width: 100%;
            height: 120px;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        
        .preview-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .canvas-container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            position: relative;
            min-height: 700px;
            width: 100%;
            max-width: 1100px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #threeCanvas {
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        
        .controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
        }
        
        .control-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        
        .control-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }
        
        .control-btn.active {
            background: rgba(0, 184, 148, 0.8);
        }
        
        .instructions {
            background: rgba(255, 255, 255, 0.15);
            color: white;
            padding: 25px;
            border-radius: 15px;
            margin-top: 30px;
            font-size: 1.1rem;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }
        
        .instructions p {
            margin: 0;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }
        
        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }
            
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .canvas-container {
                min-height: 400px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>3D卡片翻转效果</h1>
        <p class="description">上传您的图片，创建3D卡片模型。卡片会像真实卡片一样翻转，显示正面和背面。</p>
        
        <div class="main-content">
            <!-- 上传区域 -->
            <div class="upload-section">
                <h2 class="upload-title">📸 上传图片创建3D卡片</h2>
                <form class="upload-form" id="uploadForm">
                    <div class="file-input-group">
                        <label for="modelFile" class="file-label">
                            <span class="file-icon">🎲</span>
                            <span class="file-text">选择3D模型文件 (GLB/GLTF，可选)</span>
                            <input type="file" id="modelFile" accept=".glb,.gltf" class="file-input">
                        </label>
                    </div>
                    <div class="file-input-group">
                        <label for="frontImage" class="file-label">
                            <span class="file-icon">📷</span>
                            <span class="file-text">选择正面图片</span>
                            <input type="file" id="frontImage" accept="image/*" class="file-input">
                        </label>
                        <label for="backImage" class="file-label">
                            <span class="file-icon">🖼️</span>
                            <span class="file-text">选择背面图片</span>
                            <input type="file" id="backImage" accept="image/*" class="file-input">
                        </label>
                    </div>
                    <button type="submit" class="upload-btn" id="uploadBtn">创建3D卡片</button>
                </form>
                
                <!-- 预览区域 -->
                <div class="preview-section" id="previewSection">
                    <div class="preview-images">
                        <div>
                            <div class="preview-label">正面预览</div>
                            <div class="preview-image" id="frontPreview"></div>
                        </div>
                        <div>
                            <div class="preview-label">背面预览</div>
                            <div class="preview-image" id="backPreview"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- 3D渲染区域 -->
            <div class="canvas-container">
                <canvas id="threeCanvas"></canvas>
                <div class="controls">
                    <button class="control-btn" id="autoRotateBtn">自动旋转</button>
                    <button class="control-btn" id="manualRotateBtn">手动控制</button>
                </div>
            </div>
        </div>
        
        <!-- 使用说明 -->
        <div class="instructions">
            <p>💡 使用说明：上传正面和背面图片，点击"创建3D卡片"按钮生成3D卡片模型。卡片会像真实卡片一样翻转，使用控制按钮切换自动翻转或手动控制模式！</p>
            <p>🖱️ 交互控制：鼠标移动控制卡片翻转，滚轮缩放控制远近（距离范围：2-20）</p>
        </div>
    </div>

    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- GLTFLoader -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    
    <script>
        // 全局变量
        let scene, camera, renderer, cube, frontTexture, backTexture, backTextureOriginal;
        let isAutoRotating = true;
        let mouseX = 0, mouseY = 0;
        let targetRotationX = 0, targetRotationY = 0;
        let cameraDistance = 3; // 相机距离（调整为更近）
        let minDistance = 1.5; // 最小距离
        let maxDistance = 20; // 最大距离
        // 自定义模型贴图平面
        let frontPlane = null, backPlane = null;
        let gltfLoader;
        // 动态光源（用于旋转时的光效）
        let dynamicLight1, dynamicLight2;
        
        // DOM元素
        const uploadForm = document.getElementById('uploadForm');
        const modelFileInput = document.getElementById('modelFile');
        const frontImageInput = document.getElementById('frontImage');
        const backImageInput = document.getElementById('backImage');
        const previewSection = document.getElementById('previewSection');
        const frontPreview = document.getElementById('frontPreview');
        const backPreview = document.getElementById('backPreview');
        const uploadBtn = document.getElementById('uploadBtn');
        const autoRotateBtn = document.getElementById('autoRotateBtn');
        const manualRotateBtn = document.getElementById('manualRotateBtn');
        const canvas = document.getElementById('threeCanvas');
        
        // 初始化Three.js场景
        function initThreeJS() {
            // 创建场景
            scene = new THREE.Scene();
            
            // 创建相机
            camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
            camera.position.z = cameraDistance; // 从正前方观察卡片
            camera.position.y = 0.5; // 稍微抬高一点，模拟视线高度
            camera.lookAt(0, 0, 0); // 看向场景中心
            
            // 创建高质量渲染器
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas, 
                antialias: true,  // 开启抗锯齿
                alpha: true,
                powerPreference: "high-performance",
                precision: "highp"  // 高精度渲染
            });
            renderer.setSize(600, 600);  // 增大渲染尺寸，提升清晰度
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));  // 支持高DPI显示
            renderer.setClearColor(0x000000, 0);
            
            // 启用高质量阴影
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;  // 柔和阴影
            renderer.shadowMap.autoUpdate = true;
            
            // 设置色调映射和编码，提升视觉质量
            renderer.toneMapping = THREE.LinearToneMapping;  // 使用线性色调映射，保持自然
            renderer.toneMappingExposure = 1.0;
            renderer.outputEncoding = THREE.sRGBEncoding;  // 正确的颜色空间
            
            // 启用物理正确的光照
            renderer.physicallyCorrectLights = true;
            
            // 添加自然光照系统
            // 环境光 - 提供基础照明（增强）
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            
            // 主光源 - 模拟太阳光（增强）
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(5, 5, 5);
            directionalLight.castShadow = true;
            
            // 高质量阴影设置
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -10;
            directionalLight.shadow.camera.right = 10;
            directionalLight.shadow.camera.top = 10;
            directionalLight.shadow.camera.bottom = -10;
            directionalLight.shadow.bias = -0.0001;  // 减少阴影瑕疵
            scene.add(directionalLight);
            
            // 补光 - 从左侧照亮，减少暗部（增强）
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.6);
            fillLight.position.set(-5, 3, -3);
            scene.add(fillLight);
            
            // 背光 - 增加轮廓光，让模型更立体（增强）
            const backLight = new THREE.DirectionalLight(0xffffff, 0.5);
            backLight.position.set(0, 3, -5);
            scene.add(backLight);
            
            // 半球光 - 模拟天空和地面的反射光（增强）
            const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x888888, 0.5);
            hemisphereLight.position.set(0, 10, 0);
            scene.add(hemisphereLight);
            
            // 添加动态点光源 - 跟随卡片旋转产生自然光效
            // 暖色调动态光（模拟阳光在卡片表面的反射）
            dynamicLight1 = new THREE.PointLight(0xffd700, 0.8, 10);
            dynamicLight1.position.set(3, 2, 3);
            scene.add(dynamicLight1);
            
            // 冷色调动态光（模拟环境光反射）
            dynamicLight2 = new THREE.PointLight(0x4da6ff, 0.6, 10);
            dynamicLight2.position.set(-3, 2, 3);
            scene.add(dynamicLight2);
            
            // 创建默认立方体
            createDefaultCube();
            // 初始化加载器
            gltfLoader = new THREE.GLTFLoader();
            
            // 开始渲染循环
            animate();
        }
        
        // 计算图片比例
        function calculateAspectRatio(frontImageData, backImageData) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = function() {
                    const aspectRatio = this.width / this.height;
                    resolve(aspectRatio);
                };
                img.src = frontImageData;
            });
        }
        
        // 创建默认卡片
        function createDefaultCube() {
            // 默认比例使用标准卡片比例（游戏王卡片 63:88 ≈ 0.716）
            const aspectRatio = 0.716;
            const baseHeight = 4;
            const width = baseHeight * aspectRatio;
            const height = baseHeight;
            
            // 竖立的卡片：width(X轴), height(Y轴), thickness(Z轴)
            // 正面和背面在前后(±Z)方向
            const geometry = new THREE.BoxGeometry(width, height, 0.05);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0x4a90e2,
                transparent: true,
                opacity: 0.8,
                metalness: 0.2,
                roughness: 0.3,
                envMapIntensity: 0.8
            });
            
            cube = new THREE.Mesh(geometry, material);
            cube.castShadow = true;
            cube.receiveShadow = true;
            scene.add(cube);
        }
        
        // 创建带贴图的卡片
        async function createTexturedCube(frontImageData, backImageData) {
            // 如已存在贴图平面，先清理
            if (frontPlane) {
                if (frontPlane.parent) frontPlane.parent.remove(frontPlane);
                if (frontPlane.material) frontPlane.material.dispose();
                if (frontPlane.geometry) frontPlane.geometry.dispose();
            }
            if (backPlane) {
                if (backPlane.parent) backPlane.parent.remove(backPlane);
                if (backPlane.material) backPlane.material.dispose();
                if (backPlane.geometry) backPlane.geometry.dispose();
            }
            
            // 如果当前是默认卡片，则重建卡片网格；否则为自定义模型，仅附加贴图平面
            const isDefaultCard = !cube || cube.geometry instanceof THREE.BoxGeometry;
            let width, height;
            if (isDefaultCard) {
                // 根据实际图片比例计算卡片尺寸
                const aspectRatio = await calculateAspectRatio(frontImageData, backImageData);
                const baseHeight = 4;  // 基准高度
                width = baseHeight * aspectRatio;   // 根据实际图片宽高比计算宽度
                height = baseHeight;        // 高度为4
                
                if (cube) scene.remove(cube);
                // BoxGeometry参数：X轴宽度, Y轴高度, Z轴厚度
                // 竖立的卡片，贴图在前(+Z)和后(-Z)面
                const geometry = new THREE.BoxGeometry(width, height, 0.05);
                const frontMaterial = new THREE.MeshStandardMaterial({ 
                    map: frontTexture, 
                    transparent: true,
                    metalness: 0.15,      // 增加金属感，让卡片更有光泽
                    roughness: 0.3,       // 降低粗糙度，增加反光效果
                    envMapIntensity: 0.8, // 增强环境反射
                    side: THREE.FrontSide // 只渲染正面
                });
                const backMaterial = new THREE.MeshStandardMaterial({ 
                    map: backTexture, 
                    transparent: true,
                    metalness: 0.15,
                    roughness: 0.3,
                    envMapIntensity: 0.8,
                    side: THREE.FrontSide
                });
                const edgeMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffffff, 
                    transparent: true, 
                    opacity: 0.3,
                    metalness: 0.1,
                    roughness: 0.7
                });
                // 材质顺序: [右(+X), 左(-X), 顶(+Y), 底(-Y), 前(+Z)=正面, 后(-Z)=背面]
                const materials = [edgeMaterial, edgeMaterial, edgeMaterial, edgeMaterial, frontMaterial, backMaterial];
                cube = new THREE.Mesh(geometry, materials);
                cube.castShadow = true;
                cube.receiveShadow = true;
                scene.add(cube);
                return;
            } else {
                // 自定义模型：使用旋转后的包围盒尺寸
                const size = cube.userData.size || new THREE.Vector3(1, 1, 1);
                const dims = [
                    { v: size.x, axis: 'x', idx: 0 },
                    { v: size.y, axis: 'y', idx: 1 },
                    { v: size.z, axis: 'z', idx: 2 }
                ].sort((a,b)=>a.v-b.v); // 从小到大排序
                const shortest = dims[0];
                
                // 根据最短轴确定贴图平面的宽高
                let width, height;
                // 贴图平面放在包围盒表面上方一点点
                const offset = shortest.v/2 + 0.001;  // 在包围盒表面外侧1mm处
                
                if (shortest.idx === 2) {
                    // Z轴最短 - 贴图在XY平面
                    width = size.x;
                    height = size.y;
                } else if (shortest.idx === 0) {
                    // X轴最短 - 贴图在YZ平面
                    width = size.z;
                    height = size.y;
                } else {
                    // Y轴最短 - 贴图在XZ平面
                    width = size.x;
                    height = size.z;
                }
                
                const geoFront = new THREE.PlaneGeometry(width, height);
                const geoBack = new THREE.PlaneGeometry(width, height);
                
                // 为自定义模型创建正面和背面纹理副本，根据旋转调整
                const customFrontTexture = frontTexture.clone();
                customFrontTexture.needsUpdate = true;
                customFrontTexture.wrapS = THREE.RepeatWrapping;
                customFrontTexture.wrapT = THREE.RepeatWrapping;
                
                const customBackTexture = backTextureOriginal.clone();
                customBackTexture.needsUpdate = true;
                customBackTexture.wrapS = THREE.RepeatWrapping;
                customBackTexture.wrapT = THREE.RepeatWrapping;
                
        // 创建圆角遮罩，避免矩形图片在圆角模型上露出黑边
        const alphaMask = createRoundedCornerMask(0.0);
                
                const matFront = new THREE.MeshStandardMaterial({ 
                    map: customFrontTexture,
                    alphaMap: alphaMask,  // 添加圆角遮罩
                    transparent: true, 
                    side: THREE.DoubleSide,
                    metalness: 0.15,
                    roughness: 0.3,
                    envMapIntensity: 0.8
                });
                const matBack = new THREE.MeshStandardMaterial({ 
                    map: customBackTexture,
                    alphaMap: alphaMask,  // 添加圆角遮罩
                    transparent: true, 
                    side: THREE.DoubleSide,
                    metalness: 0.15,
                    roughness: 0.3,
                    envMapIntensity: 0.8
                });
                frontPlane = new THREE.Mesh(geoFront, matFront);
                backPlane = new THREE.Mesh(geoBack, matBack);
                
                // 启用阴影
                frontPlane.castShadow = true;
                frontPlane.receiveShadow = true;
                backPlane.castShadow = true;
                backPlane.receiveShadow = true;
                
                // 贴图平面添加到cube容器（而不是内部的gltf.scene）
                cube.add(frontPlane);
                cube.add(backPlane);
                
                // 根据旋转后的最短轴来放置贴图平面
                console.log('自定义模型尺寸:', size);
                console.log('最短轴:', shortest.axis, '索引:', shortest.idx, '值:', shortest.v);
                console.log('平面尺寸 width x height:', width, 'x', height);
                console.log('offset偏移量:', offset);
                
                if (shortest.idx === 2) {
                    // Z轴最短（厚度在Z方向）- 贴图在前后（±Z面）
                    // 平面默认在XY平面，贴图U→X, V→Y
                    // 正面和背面直接贴图，无翻转
                    frontPlane.position.set(0, 0, offset);
                    backPlane.position.set(0, 0, -offset);
                    backPlane.rotateY(Math.PI);
                } else if (shortest.idx === 0) {
                    // X轴最短（厚度在X方向）- 贴图在左右（±X面）
                    // 平面旋转到YZ平面，此时贴图U→Z, V→Y
                    // 正面和背面直接贴图，无翻转
                    frontPlane.rotation.y = Math.PI/2;
                    frontPlane.position.set(offset, 0, 0);
                    backPlane.rotation.y = -Math.PI/2;
                    backPlane.position.set(-offset, 0, 0);
                } else {
                    // Y轴最短（厚度在Y方向）- 贴图在上下（±Y面）
                    // 平面旋转到XZ平面，此时贴图U→X, V→Z
                    // 正面和背面直接贴图，无翻转
                    frontPlane.rotation.x = -Math.PI/2;
                    frontPlane.position.set(0, offset, 0);
                    backPlane.rotation.x = Math.PI/2;
                    backPlane.position.set(0, -offset, 0);
                }
                frontPlane.renderOrder = 1; backPlane.renderOrder = 1;
                return;
            }
        }
        
        // 创建圆角遮罩纹理，用于避免矩形图片在圆角模型上露出黑边
        function createRoundedCornerMask(cornerRadius = 0.08) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // 背景设为黑色（完全透明区域）
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 绘制白色圆角矩形（不透明区域）
            ctx.fillStyle = 'white';
            ctx.beginPath();
            const x = 0, y = 0, w = canvas.width, h = canvas.height;
            const r = cornerRadius * Math.min(w, h); // 圆角半径
            
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.arcTo(x + w, y, x + w, y + r, r);
            ctx.lineTo(x + w, y + h - r);
            ctx.arcTo(x + w, y + h, x + w - r, y + h, r);
            ctx.lineTo(x + r, y + h);
            ctx.arcTo(x, y + h, x, y + h - r, r);
            ctx.lineTo(x, y + r);
            ctx.arcTo(x, y, x + r, y, r);
            ctx.closePath();
            ctx.fill();
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }
        
        // 创建高质量纹理
        function createTexture(imageData, rotation = 0, flipY = false, flipX = false) {
            const texture = new THREE.Texture();
            const image = new Image();
            image.onload = function() {
                texture.image = image;
                texture.needsUpdate = true;
            };
            image.src = imageData;
            
            // 设置高质量纹理过滤
            texture.minFilter = THREE.LinearMipmapLinearFilter;  // 最佳质量的缩小过滤
            texture.magFilter = THREE.LinearFilter;              // 放大时使用线性过滤
            texture.anisotropy = renderer ? renderer.capabilities.getMaxAnisotropy() : 16;  // 各向异性过滤，提升清晰度
            texture.encoding = THREE.sRGBEncoding;  // 正确的颜色编码
            
            // 如果需要翻转Y轴或X轴
            if (flipY || flipX) {
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                
                if (flipY) {
                    texture.repeat.y = -1; // 翻转V方向（垂直）
                    texture.offset.y = 1;   // 调整偏移以补偿翻转
                }
                
                if (flipX) {
                    texture.repeat.x = -1; // 翻转U方向（水平）
                    texture.offset.x = 1;   // 调整偏移以补偿翻转
                }
            }
            
            // 如果需要旋转纹理
            if (rotation !== 0) {
                texture.center = new THREE.Vector2(0.5, 0.5); // 设置旋转中心为纹理中心
                texture.rotation = rotation; // 设置旋转角度（弧度）
            }
            
            return texture;
        }
        
        // 渲染循环
        function animate() {
            requestAnimationFrame(animate);
            
            if (cube) {
                if (isAutoRotating) {
                    // 卡片式翻转：绕Y轴旋转（竖立的卡片左右翻转）
                    cube.rotation.y += 0.01;
                } else {
                    // 手动控制：控制Y轴旋转
                    cube.rotation.y += (targetRotationY - cube.rotation.y) * 0.1;
                }
                
                // 动态光效：让光源跟随卡片旋转，产生自然的光线变化
                const time = Date.now() * 0.001; // 时间因子
                const rotationY = cube.rotation.y;
                
                // 动态光1 - 围绕卡片旋转（模拟主光源反射）
                dynamicLight1.position.x = Math.cos(rotationY + time * 0.5) * 4;
                dynamicLight1.position.z = Math.sin(rotationY + time * 0.5) * 4;
                dynamicLight1.position.y = 2 + Math.sin(time * 0.3) * 0.5;
                
                // 动态光2 - 反向旋转（模拟环境补光）
                dynamicLight2.position.x = Math.cos(rotationY - time * 0.3) * 3.5;
                dynamicLight2.position.z = Math.sin(rotationY - time * 0.3) * 3.5;
                dynamicLight2.position.y = 2 + Math.cos(time * 0.4) * 0.5;
                
                // 根据旋转角度微调光照强度，产生更自然的效果
                const intensityFactor = Math.abs(Math.sin(rotationY * 0.5)) * 0.3 + 0.7;
                dynamicLight1.intensity = 0.8 * intensityFactor;
                dynamicLight2.intensity = 0.6 * (1.1 - intensityFactor * 0.5);
            }
            
            renderer.render(scene, camera);
        }
        
        // 处理图片预览
        function handleImagePreview(input, previewElement) {
            const file = input.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    previewElement.innerHTML = `<img src="${e.target.result}" alt="预览">`;
                };
                reader.readAsDataURL(file);
            }
        }
        
        // 监听文件输入变化
        modelFileInput.addEventListener('change', function() {
            // 仅记录选择，实际加载在提交且图片就绪后统一处理
        });
        frontImageInput.addEventListener('change', function() {
            handleImagePreview(this, frontPreview);
        });
        
        backImageInput.addEventListener('change', function() {
            handleImagePreview(this, backPreview);
        });
        
        // 处理表单提交
        uploadForm.addEventListener('submit', function(e) {
            e.preventDefault();
            
            const frontFile = frontImageInput.files[0];
            const backFile = backImageInput.files[0];
            
            if (!frontFile || !backFile) {
                alert('请选择正面和背面图片！');
                return;
            }
            
            uploadBtn.disabled = true;
            uploadBtn.textContent = '创建中...';
            
            // 处理图片并创建纹理
            const frontReader = new FileReader();
            frontReader.onload = async function(e) {
                const frontImageData = e.target.result;
                frontTexture = createTexture(frontImageData, 0, false, false); // 正面纹理直接贴图，无翻转
                
                const backReader = new FileReader();
                backReader.onload = async function(e) {
                    const backImageData = e.target.result;
                    backTexture = createTexture(backImageData, 0, false, false); // 背面纹理直接贴图，无翻转
                    backTextureOriginal = createTexture(backImageData, 0, false, false); // 原始背面纹理（用于自定义模型）
                    
                    // 如果选择了自定义模型，则先解析模型，再附加正/背面贴图平面；
                    const modelFile = modelFileInput.files && modelFileInput.files[0];
                    if (modelFile) {
                        const reader = new FileReader();
                        reader.onload = function(ev) {
                            const arrayBuffer = ev.target.result;
                            gltfLoader.parse(arrayBuffer, '', function(gltf) {
                                if (cube) scene.remove(cube);
                                
                                // 计算包围盒，确定模型朝向
                                scene.add(gltf.scene);
                                const box = new THREE.Box3().setFromObject(gltf.scene);
                                const size = box.getSize(new THREE.Vector3());
                                scene.remove(gltf.scene);
                                
                                // 判断模型朝向：如果Y轴最短，说明是平躺的，需要竖立
                                const dims = [
                                    { v: size.x, axis: 'x', idx: 0 },
                                    { v: size.y, axis: 'y', idx: 1 },
                                    { v: size.z, axis: 'z', idx: 2 }
                                ].sort((a,b)=>a.v-b.v); // 从小到大排序
                                const shortest = dims[0];
                                
                                // 如果Y轴最短，说明模型是平躺的，绕X轴旋转-90度竖立
                                if (shortest.idx === 1) {
                                    gltf.scene.rotation.x = -Math.PI / 2;
                                }
                                
                                // 放大模型以便更好地查看
                                const modelScale = 3.5; // 放大3.5倍
                                gltf.scene.scale.set(modelScale, modelScale, modelScale);
                                
                                // 旋转和缩放后重新计算包围盒并居中
                                scene.add(gltf.scene);
                                const rotatedBox = new THREE.Box3().setFromObject(gltf.scene);
                                const rotatedCenter = rotatedBox.getCenter(new THREE.Vector3());
                                scene.remove(gltf.scene);
                                gltf.scene.position.sub(rotatedCenter);
                                
                                // 创建容器组
                                cube = new THREE.Group();
                                
                                // 为模型中的所有网格启用阴影和高质量材质
                                gltf.scene.traverse(function(child) {
                                    if (child.isMesh) {
                                        child.castShadow = true;
                                        child.receiveShadow = true;
                                        
                                        // 升级所有材质为MeshStandardMaterial以获得更好的光照效果
                                        if (child.material) {
                                            const oldMaterial = child.material;
                                            
                                            // 如果是BasicMaterial，升级为StandardMaterial
                                            if (oldMaterial.isMeshBasicMaterial) {
                                                child.material = new THREE.MeshStandardMaterial({
                                                    map: oldMaterial.map,
                                                    color: oldMaterial.color,
                                                    transparent: oldMaterial.transparent,
                                                    opacity: oldMaterial.opacity,
                                                    side: oldMaterial.side,
                                                    metalness: 0.15,
                                                    roughness: 0.3,
                                                    envMapIntensity: 0.8
                                                });
                                            } 
                                            // 如果已经是StandardMaterial，确保有正确的光照参数
                                            else if (oldMaterial.isMeshStandardMaterial) {
                                                oldMaterial.metalness = oldMaterial.metalness !== undefined ? oldMaterial.metalness : 0.15;
                                                oldMaterial.roughness = oldMaterial.roughness !== undefined ? oldMaterial.roughness : 0.3;
                                                oldMaterial.envMapIntensity = 0.8;
                                                oldMaterial.needsUpdate = true;
                                            }
                                        }
                                    }
                                });
                                
                                cube.add(gltf.scene);
                                scene.add(cube);
                                
                                // 使用之前计算的旋转后包围盒尺寸
                                const rotatedSize = rotatedBox.getSize(new THREE.Vector3());
                                cube.userData.size = rotatedSize;
                                console.log('GLB模型加载完成，旋转后尺寸:', rotatedSize);
                                
                                // 附加正/背面贴图平面
                                createTexturedCube(frontImageData, backImageData).then(()=>{
                                    uploadBtn.disabled = false;
                                    uploadBtn.textContent = '创建3D卡片';
                                    previewSection.style.display = 'block';
                                });
                            }, function(err){
                                console.error('模型解析失败', err);
                                // 回退为默认卡片
                                createTexturedCube(frontImageData, backImageData).then(()=>{
                                    uploadBtn.disabled = false;
                                    uploadBtn.textContent = '创建3D卡片';
                                    previewSection.style.display = 'block';
                                });
                            });
                        };
                        reader.readAsArrayBuffer(modelFile);
                    } else {
                        // 默认卡片路径
                        setTimeout(async () => {
                            await createTexturedCube(frontImageData, backImageData);
                            uploadBtn.disabled = false;
                            uploadBtn.textContent = '创建3D卡片';
                            previewSection.style.display = 'block';
                        }, 300);
                    }
                };
                backReader.readAsDataURL(backFile);
            };
            frontReader.readAsDataURL(frontFile);
        });
        
        // 控制按钮事件
        autoRotateBtn.addEventListener('click', function() {
            isAutoRotating = true;
            autoRotateBtn.classList.add('active');
            manualRotateBtn.classList.remove('active');
        });
        
        manualRotateBtn.addEventListener('click', function() {
            isAutoRotating = false;
            manualRotateBtn.classList.add('active');
            autoRotateBtn.classList.remove('active');
        });
        
        // 鼠标控制
        canvas.addEventListener('mousemove', function(event) {
            if (!isAutoRotating) {
                const rect = canvas.getBoundingClientRect();
                mouseX = (event.clientX - rect.left) / rect.width;
                
                // 控制Y轴旋转，竖立的卡片左右翻转
                targetRotationY = (mouseX - 0.5) * Math.PI * 2;
            }
        });
        
        // 鼠标滚轮缩放控制
        canvas.addEventListener('wheel', function(event) {
            event.preventDefault();
            
            // 计算缩放增量
            const zoomSpeed = 0.5;
            const delta = event.deltaY > 0 ? zoomSpeed : -zoomSpeed;
            
            // 更新相机距离
            cameraDistance += delta;
            
            // 限制距离范围
            cameraDistance = Math.max(minDistance, Math.min(maxDistance, cameraDistance));
            
            // 更新相机位置（相机在Z轴）
            camera.position.z = cameraDistance;
        });
        
        // 初始化
        initThreeJS();
        
        // 默认激活自动旋转
        autoRotateBtn.classList.add('active');
    </script>
</body>
</html>
