<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3Dç«‹æ–¹ä½“æ¨¡å‹ - å›¾ç‰‡è´´å›¾æ—‹è½¬</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Microsoft YaHei', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 20px;
            overflow-x: hidden;
        }
        
        .container {
            text-align: center;
            max-width: 1200px;
            width: 100%;
        }
        
        h1 {
            color: white;
            font-size: 3rem;
            margin-bottom: 20px;
            text-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            font-weight: 300;
            letter-spacing: 2px;
        }
        
        .description {
            color: rgba(255, 255, 255, 0.9);
            font-size: 1.2rem;
            max-width: 800px;
            margin: 0 auto 50px;
            line-height: 1.8;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }
        
        .main-content {
            display: flex;
            flex-direction: column;
            gap: 30px;
            align-items: center;
        }
        
        .upload-section {
            background: rgba(255, 255, 255, 0.1);
            padding: 40px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 1100px;
        }
        
        .upload-title {
            color: white;
            font-size: 1.8rem;
            margin-bottom: 30px;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }
        
        .upload-form {
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
        }
        
        .file-input-group {
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 100%;
        }
        
        .file-label {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .file-label:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-2px);
        }
        
        .file-icon {
            font-size: 2rem;
            margin-bottom: 10px;
        }
        
        .file-text {
            color: white;
            font-size: 1rem;
            text-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        
        .file-input {
            display: none;
        }
        
        .upload-btn {
            background: linear-gradient(135deg, #00b894, #00a085);
            color: white;
            border: none;
            padding: 15px 40px;
            border-radius: 25px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 184, 148, 0.3);
            text-transform: uppercase;
            letter-spacing: 1px;
            width: 100%;
        }
        
        .upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 184, 148, 0.4);
        }
        
        .upload-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .preview-section {
            margin-top: 30px;
            display: none;
        }
        
        .preview-images {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .preview-label {
            color: white;
            font-size: 1rem;
            margin-bottom: 10px;
            text-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        
        .preview-image {
            width: 100%;
            height: 120px;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        
        .preview-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .canvas-container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            position: relative;
            min-height: 700px;
            width: 100%;
            max-width: 1100px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #threeCanvas {
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        
        .controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
        }
        
        .control-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        
        .control-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }
        
        .control-btn.active {
            background: rgba(0, 184, 148, 0.8);
        }
        
        .instructions {
            background: rgba(255, 255, 255, 0.15);
            color: white;
            padding: 25px;
            border-radius: 15px;
            margin-top: 30px;
            font-size: 1.1rem;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }
        
        .instructions p {
            margin: 0;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }
        
        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }
            
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .canvas-container {
                min-height: 400px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>3Då¡ç‰‡ç¿»è½¬æ•ˆæœ</h1>
        <p class="description">ä¸Šä¼ æ‚¨çš„å›¾ç‰‡ï¼Œåˆ›å»º3Då¡ç‰‡æ¨¡å‹ã€‚å¡ç‰‡ä¼šåƒçœŸå®å¡ç‰‡ä¸€æ ·ç¿»è½¬ï¼Œæ˜¾ç¤ºæ­£é¢å’ŒèƒŒé¢ã€‚</p>
        
        <div class="main-content">
            <!-- ä¸Šä¼ åŒºåŸŸ -->
            <div class="upload-section">
                <h2 class="upload-title">ğŸ“¸ ä¸Šä¼ å›¾ç‰‡åˆ›å»º3Då¡ç‰‡</h2>
                <form class="upload-form" id="uploadForm">
                    <div class="file-input-group">
                        <label for="modelFile" class="file-label">
                            <span class="file-icon">ğŸ²</span>
                            <span class="file-text">é€‰æ‹©3Dæ¨¡å‹æ–‡ä»¶ (GLB/GLTFï¼Œå¯é€‰)</span>
                            <input type="file" id="modelFile" accept=".glb,.gltf" class="file-input">
                        </label>
                    </div>
                    <div class="file-input-group">
                        <label for="frontImage" class="file-label">
                            <span class="file-icon">ğŸ“·</span>
                            <span class="file-text">é€‰æ‹©æ­£é¢å›¾ç‰‡</span>
                            <input type="file" id="frontImage" accept="image/*" class="file-input">
                        </label>
                        <label for="backImage" class="file-label">
                            <span class="file-icon">ğŸ–¼ï¸</span>
                            <span class="file-text">é€‰æ‹©èƒŒé¢å›¾ç‰‡</span>
                            <input type="file" id="backImage" accept="image/*" class="file-input">
                        </label>
                    </div>
                    <button type="submit" class="upload-btn" id="uploadBtn">åˆ›å»º3Då¡ç‰‡</button>
                </form>
                
                <!-- é¢„è§ˆåŒºåŸŸ -->
                <div class="preview-section" id="previewSection">
                    <div class="preview-images">
                        <div>
                            <div class="preview-label">æ­£é¢é¢„è§ˆ</div>
                            <div class="preview-image" id="frontPreview"></div>
                        </div>
                        <div>
                            <div class="preview-label">èƒŒé¢é¢„è§ˆ</div>
                            <div class="preview-image" id="backPreview"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- 3Dæ¸²æŸ“åŒºåŸŸ -->
            <div class="canvas-container">
                <canvas id="threeCanvas"></canvas>
                <div class="controls">
                    <button class="control-btn" id="autoRotateBtn">è‡ªåŠ¨æ—‹è½¬</button>
                    <button class="control-btn" id="manualRotateBtn">æ‰‹åŠ¨æ§åˆ¶</button>
                </div>
            </div>
        </div>
        
        <!-- ä½¿ç”¨è¯´æ˜ -->
        <div class="instructions">
            <p>ğŸ’¡ ä½¿ç”¨è¯´æ˜ï¼šä¸Šä¼ æ­£é¢å’ŒèƒŒé¢å›¾ç‰‡ï¼Œç‚¹å‡»"åˆ›å»º3Då¡ç‰‡"æŒ‰é’®ç”Ÿæˆ3Då¡ç‰‡æ¨¡å‹ã€‚å¡ç‰‡ä¼šåƒçœŸå®å¡ç‰‡ä¸€æ ·ç¿»è½¬ï¼Œä½¿ç”¨æ§åˆ¶æŒ‰é’®åˆ‡æ¢è‡ªåŠ¨ç¿»è½¬æˆ–æ‰‹åŠ¨æ§åˆ¶æ¨¡å¼ï¼</p>
            <p>ğŸ–±ï¸ äº¤äº’æ§åˆ¶ï¼šé¼ æ ‡ç§»åŠ¨æ§åˆ¶å¡ç‰‡ç¿»è½¬ï¼Œæ»šè½®ç¼©æ”¾æ§åˆ¶è¿œè¿‘ï¼ˆè·ç¦»èŒƒå›´ï¼š2-20ï¼‰</p>
        </div>
    </div>

    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- GLTFLoader -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    
    <script>
        // å…¨å±€å˜é‡
        let scene, camera, renderer, cube, frontTexture, backTexture, backTextureOriginal;
        let isAutoRotating = true;
        let mouseX = 0, mouseY = 0;
        let targetRotationX = 0, targetRotationY = 0;
        let cameraDistance = 3; // ç›¸æœºè·ç¦»ï¼ˆè°ƒæ•´ä¸ºæ›´è¿‘ï¼‰
        let minDistance = 1.5; // æœ€å°è·ç¦»
        let maxDistance = 20; // æœ€å¤§è·ç¦»
        // è‡ªå®šä¹‰æ¨¡å‹è´´å›¾å¹³é¢
        let frontPlane = null, backPlane = null;
        let gltfLoader;
        // åŠ¨æ€å…‰æºï¼ˆç”¨äºæ—‹è½¬æ—¶çš„å…‰æ•ˆï¼‰
        let dynamicLight1, dynamicLight2;
        
        // DOMå…ƒç´ 
        const uploadForm = document.getElementById('uploadForm');
        const modelFileInput = document.getElementById('modelFile');
        const frontImageInput = document.getElementById('frontImage');
        const backImageInput = document.getElementById('backImage');
        const previewSection = document.getElementById('previewSection');
        const frontPreview = document.getElementById('frontPreview');
        const backPreview = document.getElementById('backPreview');
        const uploadBtn = document.getElementById('uploadBtn');
        const autoRotateBtn = document.getElementById('autoRotateBtn');
        const manualRotateBtn = document.getElementById('manualRotateBtn');
        const canvas = document.getElementById('threeCanvas');
        
        // åˆå§‹åŒ–Three.jsåœºæ™¯
        function initThreeJS() {
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            
            // åˆ›å»ºç›¸æœº
            camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
            camera.position.z = cameraDistance; // ä»æ­£å‰æ–¹è§‚å¯Ÿå¡ç‰‡
            camera.position.y = 0.5; // ç¨å¾®æŠ¬é«˜ä¸€ç‚¹ï¼Œæ¨¡æ‹Ÿè§†çº¿é«˜åº¦
            camera.lookAt(0, 0, 0); // çœ‹å‘åœºæ™¯ä¸­å¿ƒ
            
            // åˆ›å»ºé«˜è´¨é‡æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas, 
                antialias: true,  // å¼€å¯æŠ—é”¯é½¿
                alpha: true,
                powerPreference: "high-performance",
                precision: "highp"  // é«˜ç²¾åº¦æ¸²æŸ“
            });
            renderer.setSize(600, 600);  // å¢å¤§æ¸²æŸ“å°ºå¯¸ï¼Œæå‡æ¸…æ™°åº¦
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));  // æ”¯æŒé«˜DPIæ˜¾ç¤º
            renderer.setClearColor(0x000000, 0);
            
            // å¯ç”¨é«˜è´¨é‡é˜´å½±
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;  // æŸ”å’Œé˜´å½±
            renderer.shadowMap.autoUpdate = true;
            
            // è®¾ç½®è‰²è°ƒæ˜ å°„å’Œç¼–ç ï¼Œæå‡è§†è§‰è´¨é‡
            renderer.toneMapping = THREE.LinearToneMapping;  // ä½¿ç”¨çº¿æ€§è‰²è°ƒæ˜ å°„ï¼Œä¿æŒè‡ªç„¶
            renderer.toneMappingExposure = 1.0;
            renderer.outputEncoding = THREE.sRGBEncoding;  // æ­£ç¡®çš„é¢œè‰²ç©ºé—´
            
            // å¯ç”¨ç‰©ç†æ­£ç¡®çš„å…‰ç…§
            renderer.physicallyCorrectLights = true;
            
            // æ·»åŠ è‡ªç„¶å…‰ç…§ç³»ç»Ÿ
            // ç¯å¢ƒå…‰ - æä¾›åŸºç¡€ç…§æ˜ï¼ˆå¢å¼ºï¼‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            
            // ä¸»å…‰æº - æ¨¡æ‹Ÿå¤ªé˜³å…‰ï¼ˆå¢å¼ºï¼‰
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(5, 5, 5);
            directionalLight.castShadow = true;
            
            // é«˜è´¨é‡é˜´å½±è®¾ç½®
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -10;
            directionalLight.shadow.camera.right = 10;
            directionalLight.shadow.camera.top = 10;
            directionalLight.shadow.camera.bottom = -10;
            directionalLight.shadow.bias = -0.0001;  // å‡å°‘é˜´å½±ç‘•ç–µ
            scene.add(directionalLight);
            
            // è¡¥å…‰ - ä»å·¦ä¾§ç…§äº®ï¼Œå‡å°‘æš—éƒ¨ï¼ˆå¢å¼ºï¼‰
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.6);
            fillLight.position.set(-5, 3, -3);
            scene.add(fillLight);
            
            // èƒŒå…‰ - å¢åŠ è½®å»“å…‰ï¼Œè®©æ¨¡å‹æ›´ç«‹ä½“ï¼ˆå¢å¼ºï¼‰
            const backLight = new THREE.DirectionalLight(0xffffff, 0.5);
            backLight.position.set(0, 3, -5);
            scene.add(backLight);
            
            // åŠçƒå…‰ - æ¨¡æ‹Ÿå¤©ç©ºå’Œåœ°é¢çš„åå°„å…‰ï¼ˆå¢å¼ºï¼‰
            const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x888888, 0.5);
            hemisphereLight.position.set(0, 10, 0);
            scene.add(hemisphereLight);
            
            // æ·»åŠ åŠ¨æ€ç‚¹å…‰æº - è·Ÿéšå¡ç‰‡æ—‹è½¬äº§ç”Ÿè‡ªç„¶å…‰æ•ˆ
            // æš–è‰²è°ƒåŠ¨æ€å…‰ï¼ˆæ¨¡æ‹Ÿé˜³å…‰åœ¨å¡ç‰‡è¡¨é¢çš„åå°„ï¼‰
            dynamicLight1 = new THREE.PointLight(0xffd700, 0.8, 10);
            dynamicLight1.position.set(3, 2, 3);
            scene.add(dynamicLight1);
            
            // å†·è‰²è°ƒåŠ¨æ€å…‰ï¼ˆæ¨¡æ‹Ÿç¯å¢ƒå…‰åå°„ï¼‰
            dynamicLight2 = new THREE.PointLight(0x4da6ff, 0.6, 10);
            dynamicLight2.position.set(-3, 2, 3);
            scene.add(dynamicLight2);
            
            // åˆ›å»ºé»˜è®¤ç«‹æ–¹ä½“
            createDefaultCube();
            // åˆå§‹åŒ–åŠ è½½å™¨
            gltfLoader = new THREE.GLTFLoader();
            
            // å¼€å§‹æ¸²æŸ“å¾ªç¯
            animate();
        }
        
        // è®¡ç®—å›¾ç‰‡æ¯”ä¾‹
        function calculateAspectRatio(frontImageData, backImageData) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = function() {
                    const aspectRatio = this.width / this.height;
                    resolve(aspectRatio);
                };
                img.src = frontImageData;
            });
        }
        
        // åˆ›å»ºé»˜è®¤å¡ç‰‡
        function createDefaultCube() {
            // é»˜è®¤æ¯”ä¾‹ä½¿ç”¨æ ‡å‡†å¡ç‰‡æ¯”ä¾‹ï¼ˆæ¸¸æˆç‹å¡ç‰‡ 63:88 â‰ˆ 0.716ï¼‰
            const aspectRatio = 0.716;
            const baseHeight = 4;
            const width = baseHeight * aspectRatio;
            const height = baseHeight;
            
            // ç«–ç«‹çš„å¡ç‰‡ï¼šwidth(Xè½´), height(Yè½´), thickness(Zè½´)
            // æ­£é¢å’ŒèƒŒé¢åœ¨å‰å(Â±Z)æ–¹å‘
            const geometry = new THREE.BoxGeometry(width, height, 0.05);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0x4a90e2,
                transparent: true,
                opacity: 0.8,
                metalness: 0.2,
                roughness: 0.3,
                envMapIntensity: 0.8
            });
            
            cube = new THREE.Mesh(geometry, material);
            cube.castShadow = true;
            cube.receiveShadow = true;
            scene.add(cube);
        }
        
        // åˆ›å»ºå¸¦è´´å›¾çš„å¡ç‰‡
        async function createTexturedCube(frontImageData, backImageData) {
            // å¦‚å·²å­˜åœ¨è´´å›¾å¹³é¢ï¼Œå…ˆæ¸…ç†
            if (frontPlane) {
                if (frontPlane.parent) frontPlane.parent.remove(frontPlane);
                if (frontPlane.material) frontPlane.material.dispose();
                if (frontPlane.geometry) frontPlane.geometry.dispose();
            }
            if (backPlane) {
                if (backPlane.parent) backPlane.parent.remove(backPlane);
                if (backPlane.material) backPlane.material.dispose();
                if (backPlane.geometry) backPlane.geometry.dispose();
            }
            
            // å¦‚æœå½“å‰æ˜¯é»˜è®¤å¡ç‰‡ï¼Œåˆ™é‡å»ºå¡ç‰‡ç½‘æ ¼ï¼›å¦åˆ™ä¸ºè‡ªå®šä¹‰æ¨¡å‹ï¼Œä»…é™„åŠ è´´å›¾å¹³é¢
            const isDefaultCard = !cube || cube.geometry instanceof THREE.BoxGeometry;
            let width, height;
            if (isDefaultCard) {
                // æ ¹æ®å®é™…å›¾ç‰‡æ¯”ä¾‹è®¡ç®—å¡ç‰‡å°ºå¯¸
                const aspectRatio = await calculateAspectRatio(frontImageData, backImageData);
                const baseHeight = 4;  // åŸºå‡†é«˜åº¦
                width = baseHeight * aspectRatio;   // æ ¹æ®å®é™…å›¾ç‰‡å®½é«˜æ¯”è®¡ç®—å®½åº¦
                height = baseHeight;        // é«˜åº¦ä¸º4
                
                if (cube) scene.remove(cube);
                // BoxGeometryå‚æ•°ï¼šXè½´å®½åº¦, Yè½´é«˜åº¦, Zè½´åšåº¦
                // ç«–ç«‹çš„å¡ç‰‡ï¼Œè´´å›¾åœ¨å‰(+Z)å’Œå(-Z)é¢
                const geometry = new THREE.BoxGeometry(width, height, 0.05);
                const frontMaterial = new THREE.MeshStandardMaterial({ 
                    map: frontTexture, 
                    transparent: true,
                    metalness: 0.15,      // å¢åŠ é‡‘å±æ„Ÿï¼Œè®©å¡ç‰‡æ›´æœ‰å…‰æ³½
                    roughness: 0.3,       // é™ä½ç²—ç³™åº¦ï¼Œå¢åŠ åå…‰æ•ˆæœ
                    envMapIntensity: 0.8, // å¢å¼ºç¯å¢ƒåå°„
                    side: THREE.FrontSide // åªæ¸²æŸ“æ­£é¢
                });
                const backMaterial = new THREE.MeshStandardMaterial({ 
                    map: backTexture, 
                    transparent: true,
                    metalness: 0.15,
                    roughness: 0.3,
                    envMapIntensity: 0.8,
                    side: THREE.FrontSide
                });
                const edgeMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffffff, 
                    transparent: true, 
                    opacity: 0.3,
                    metalness: 0.1,
                    roughness: 0.7
                });
                // æè´¨é¡ºåº: [å³(+X), å·¦(-X), é¡¶(+Y), åº•(-Y), å‰(+Z)=æ­£é¢, å(-Z)=èƒŒé¢]
                const materials = [edgeMaterial, edgeMaterial, edgeMaterial, edgeMaterial, frontMaterial, backMaterial];
                cube = new THREE.Mesh(geometry, materials);
                cube.castShadow = true;
                cube.receiveShadow = true;
                scene.add(cube);
                return;
            } else {
                // è‡ªå®šä¹‰æ¨¡å‹ï¼šä½¿ç”¨æ—‹è½¬åçš„åŒ…å›´ç›’å°ºå¯¸
                const size = cube.userData.size || new THREE.Vector3(1, 1, 1);
                const dims = [
                    { v: size.x, axis: 'x', idx: 0 },
                    { v: size.y, axis: 'y', idx: 1 },
                    { v: size.z, axis: 'z', idx: 2 }
                ].sort((a,b)=>a.v-b.v); // ä»å°åˆ°å¤§æ’åº
                const shortest = dims[0];
                
                // æ ¹æ®æœ€çŸ­è½´ç¡®å®šè´´å›¾å¹³é¢çš„å®½é«˜
                let width, height;
                // è´´å›¾å¹³é¢æ”¾åœ¨åŒ…å›´ç›’è¡¨é¢ä¸Šæ–¹ä¸€ç‚¹ç‚¹
                const offset = shortest.v/2 + 0.001;  // åœ¨åŒ…å›´ç›’è¡¨é¢å¤–ä¾§1mmå¤„
                
                if (shortest.idx === 2) {
                    // Zè½´æœ€çŸ­ - è´´å›¾åœ¨XYå¹³é¢
                    width = size.x;
                    height = size.y;
                } else if (shortest.idx === 0) {
                    // Xè½´æœ€çŸ­ - è´´å›¾åœ¨YZå¹³é¢
                    width = size.z;
                    height = size.y;
                } else {
                    // Yè½´æœ€çŸ­ - è´´å›¾åœ¨XZå¹³é¢
                    width = size.x;
                    height = size.z;
                }
                
                const geoFront = new THREE.PlaneGeometry(width, height);
                const geoBack = new THREE.PlaneGeometry(width, height);
                
                // ä¸ºè‡ªå®šä¹‰æ¨¡å‹åˆ›å»ºæ­£é¢å’ŒèƒŒé¢çº¹ç†å‰¯æœ¬ï¼Œæ ¹æ®æ—‹è½¬è°ƒæ•´
                const customFrontTexture = frontTexture.clone();
                customFrontTexture.needsUpdate = true;
                customFrontTexture.wrapS = THREE.RepeatWrapping;
                customFrontTexture.wrapT = THREE.RepeatWrapping;
                
                const customBackTexture = backTextureOriginal.clone();
                customBackTexture.needsUpdate = true;
                customBackTexture.wrapS = THREE.RepeatWrapping;
                customBackTexture.wrapT = THREE.RepeatWrapping;
                
        // åˆ›å»ºåœ†è§’é®ç½©ï¼Œé¿å…çŸ©å½¢å›¾ç‰‡åœ¨åœ†è§’æ¨¡å‹ä¸Šéœ²å‡ºé»‘è¾¹
        const alphaMask = createRoundedCornerMask(0.0);
                
                const matFront = new THREE.MeshStandardMaterial({ 
                    map: customFrontTexture,
                    alphaMap: alphaMask,  // æ·»åŠ åœ†è§’é®ç½©
                    transparent: true, 
                    side: THREE.DoubleSide,
                    metalness: 0.15,
                    roughness: 0.3,
                    envMapIntensity: 0.8
                });
                const matBack = new THREE.MeshStandardMaterial({ 
                    map: customBackTexture,
                    alphaMap: alphaMask,  // æ·»åŠ åœ†è§’é®ç½©
                    transparent: true, 
                    side: THREE.DoubleSide,
                    metalness: 0.15,
                    roughness: 0.3,
                    envMapIntensity: 0.8
                });
                frontPlane = new THREE.Mesh(geoFront, matFront);
                backPlane = new THREE.Mesh(geoBack, matBack);
                
                // å¯ç”¨é˜´å½±
                frontPlane.castShadow = true;
                frontPlane.receiveShadow = true;
                backPlane.castShadow = true;
                backPlane.receiveShadow = true;
                
                // è´´å›¾å¹³é¢æ·»åŠ åˆ°cubeå®¹å™¨ï¼ˆè€Œä¸æ˜¯å†…éƒ¨çš„gltf.sceneï¼‰
                cube.add(frontPlane);
                cube.add(backPlane);
                
                // æ ¹æ®æ—‹è½¬åçš„æœ€çŸ­è½´æ¥æ”¾ç½®è´´å›¾å¹³é¢
                console.log('è‡ªå®šä¹‰æ¨¡å‹å°ºå¯¸:', size);
                console.log('æœ€çŸ­è½´:', shortest.axis, 'ç´¢å¼•:', shortest.idx, 'å€¼:', shortest.v);
                console.log('å¹³é¢å°ºå¯¸ width x height:', width, 'x', height);
                console.log('offsetåç§»é‡:', offset);
                
                if (shortest.idx === 2) {
                    // Zè½´æœ€çŸ­ï¼ˆåšåº¦åœ¨Zæ–¹å‘ï¼‰- è´´å›¾åœ¨å‰åï¼ˆÂ±Zé¢ï¼‰
                    // å¹³é¢é»˜è®¤åœ¨XYå¹³é¢ï¼Œè´´å›¾Uâ†’X, Vâ†’Y
                    // æ­£é¢å’ŒèƒŒé¢ç›´æ¥è´´å›¾ï¼Œæ— ç¿»è½¬
                    frontPlane.position.set(0, 0, offset);
                    backPlane.position.set(0, 0, -offset);
                    backPlane.rotateY(Math.PI);
                } else if (shortest.idx === 0) {
                    // Xè½´æœ€çŸ­ï¼ˆåšåº¦åœ¨Xæ–¹å‘ï¼‰- è´´å›¾åœ¨å·¦å³ï¼ˆÂ±Xé¢ï¼‰
                    // å¹³é¢æ—‹è½¬åˆ°YZå¹³é¢ï¼Œæ­¤æ—¶è´´å›¾Uâ†’Z, Vâ†’Y
                    // æ­£é¢å’ŒèƒŒé¢ç›´æ¥è´´å›¾ï¼Œæ— ç¿»è½¬
                    frontPlane.rotation.y = Math.PI/2;
                    frontPlane.position.set(offset, 0, 0);
                    backPlane.rotation.y = -Math.PI/2;
                    backPlane.position.set(-offset, 0, 0);
                } else {
                    // Yè½´æœ€çŸ­ï¼ˆåšåº¦åœ¨Yæ–¹å‘ï¼‰- è´´å›¾åœ¨ä¸Šä¸‹ï¼ˆÂ±Yé¢ï¼‰
                    // å¹³é¢æ—‹è½¬åˆ°XZå¹³é¢ï¼Œæ­¤æ—¶è´´å›¾Uâ†’X, Vâ†’Z
                    // æ­£é¢å’ŒèƒŒé¢ç›´æ¥è´´å›¾ï¼Œæ— ç¿»è½¬
                    frontPlane.rotation.x = -Math.PI/2;
                    frontPlane.position.set(0, offset, 0);
                    backPlane.rotation.x = Math.PI/2;
                    backPlane.position.set(0, -offset, 0);
                }
                frontPlane.renderOrder = 1; backPlane.renderOrder = 1;
                return;
            }
        }
        
        // åˆ›å»ºåœ†è§’é®ç½©çº¹ç†ï¼Œç”¨äºé¿å…çŸ©å½¢å›¾ç‰‡åœ¨åœ†è§’æ¨¡å‹ä¸Šéœ²å‡ºé»‘è¾¹
        function createRoundedCornerMask(cornerRadius = 0.08) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // èƒŒæ™¯è®¾ä¸ºé»‘è‰²ï¼ˆå®Œå…¨é€æ˜åŒºåŸŸï¼‰
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶ç™½è‰²åœ†è§’çŸ©å½¢ï¼ˆä¸é€æ˜åŒºåŸŸï¼‰
            ctx.fillStyle = 'white';
            ctx.beginPath();
            const x = 0, y = 0, w = canvas.width, h = canvas.height;
            const r = cornerRadius * Math.min(w, h); // åœ†è§’åŠå¾„
            
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.arcTo(x + w, y, x + w, y + r, r);
            ctx.lineTo(x + w, y + h - r);
            ctx.arcTo(x + w, y + h, x + w - r, y + h, r);
            ctx.lineTo(x + r, y + h);
            ctx.arcTo(x, y + h, x, y + h - r, r);
            ctx.lineTo(x, y + r);
            ctx.arcTo(x, y, x + r, y, r);
            ctx.closePath();
            ctx.fill();
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }
        
        // åˆ›å»ºé«˜è´¨é‡çº¹ç†
        function createTexture(imageData, rotation = 0, flipY = false, flipX = false) {
            const texture = new THREE.Texture();
            const image = new Image();
            image.onload = function() {
                texture.image = image;
                texture.needsUpdate = true;
            };
            image.src = imageData;
            
            // è®¾ç½®é«˜è´¨é‡çº¹ç†è¿‡æ»¤
            texture.minFilter = THREE.LinearMipmapLinearFilter;  // æœ€ä½³è´¨é‡çš„ç¼©å°è¿‡æ»¤
            texture.magFilter = THREE.LinearFilter;              // æ”¾å¤§æ—¶ä½¿ç”¨çº¿æ€§è¿‡æ»¤
            texture.anisotropy = renderer ? renderer.capabilities.getMaxAnisotropy() : 16;  // å„å‘å¼‚æ€§è¿‡æ»¤ï¼Œæå‡æ¸…æ™°åº¦
            texture.encoding = THREE.sRGBEncoding;  // æ­£ç¡®çš„é¢œè‰²ç¼–ç 
            
            // å¦‚æœéœ€è¦ç¿»è½¬Yè½´æˆ–Xè½´
            if (flipY || flipX) {
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                
                if (flipY) {
                    texture.repeat.y = -1; // ç¿»è½¬Væ–¹å‘ï¼ˆå‚ç›´ï¼‰
                    texture.offset.y = 1;   // è°ƒæ•´åç§»ä»¥è¡¥å¿ç¿»è½¬
                }
                
                if (flipX) {
                    texture.repeat.x = -1; // ç¿»è½¬Uæ–¹å‘ï¼ˆæ°´å¹³ï¼‰
                    texture.offset.x = 1;   // è°ƒæ•´åç§»ä»¥è¡¥å¿ç¿»è½¬
                }
            }
            
            // å¦‚æœéœ€è¦æ—‹è½¬çº¹ç†
            if (rotation !== 0) {
                texture.center = new THREE.Vector2(0.5, 0.5); // è®¾ç½®æ—‹è½¬ä¸­å¿ƒä¸ºçº¹ç†ä¸­å¿ƒ
                texture.rotation = rotation; // è®¾ç½®æ—‹è½¬è§’åº¦ï¼ˆå¼§åº¦ï¼‰
            }
            
            return texture;
        }
        
        // æ¸²æŸ“å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);
            
            if (cube) {
                if (isAutoRotating) {
                    // å¡ç‰‡å¼ç¿»è½¬ï¼šç»•Yè½´æ—‹è½¬ï¼ˆç«–ç«‹çš„å¡ç‰‡å·¦å³ç¿»è½¬ï¼‰
                    cube.rotation.y += 0.01;
                } else {
                    // æ‰‹åŠ¨æ§åˆ¶ï¼šæ§åˆ¶Yè½´æ—‹è½¬
                    cube.rotation.y += (targetRotationY - cube.rotation.y) * 0.1;
                }
                
                // åŠ¨æ€å…‰æ•ˆï¼šè®©å…‰æºè·Ÿéšå¡ç‰‡æ—‹è½¬ï¼Œäº§ç”Ÿè‡ªç„¶çš„å…‰çº¿å˜åŒ–
                const time = Date.now() * 0.001; // æ—¶é—´å› å­
                const rotationY = cube.rotation.y;
                
                // åŠ¨æ€å…‰1 - å›´ç»•å¡ç‰‡æ—‹è½¬ï¼ˆæ¨¡æ‹Ÿä¸»å…‰æºåå°„ï¼‰
                dynamicLight1.position.x = Math.cos(rotationY + time * 0.5) * 4;
                dynamicLight1.position.z = Math.sin(rotationY + time * 0.5) * 4;
                dynamicLight1.position.y = 2 + Math.sin(time * 0.3) * 0.5;
                
                // åŠ¨æ€å…‰2 - åå‘æ—‹è½¬ï¼ˆæ¨¡æ‹Ÿç¯å¢ƒè¡¥å…‰ï¼‰
                dynamicLight2.position.x = Math.cos(rotationY - time * 0.3) * 3.5;
                dynamicLight2.position.z = Math.sin(rotationY - time * 0.3) * 3.5;
                dynamicLight2.position.y = 2 + Math.cos(time * 0.4) * 0.5;
                
                // æ ¹æ®æ—‹è½¬è§’åº¦å¾®è°ƒå…‰ç…§å¼ºåº¦ï¼Œäº§ç”Ÿæ›´è‡ªç„¶çš„æ•ˆæœ
                const intensityFactor = Math.abs(Math.sin(rotationY * 0.5)) * 0.3 + 0.7;
                dynamicLight1.intensity = 0.8 * intensityFactor;
                dynamicLight2.intensity = 0.6 * (1.1 - intensityFactor * 0.5);
            }
            
            renderer.render(scene, camera);
        }
        
        // å¤„ç†å›¾ç‰‡é¢„è§ˆ
        function handleImagePreview(input, previewElement) {
            const file = input.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    previewElement.innerHTML = `<img src="${e.target.result}" alt="é¢„è§ˆ">`;
                };
                reader.readAsDataURL(file);
            }
        }
        
        // ç›‘å¬æ–‡ä»¶è¾“å…¥å˜åŒ–
        modelFileInput.addEventListener('change', function() {
            // ä»…è®°å½•é€‰æ‹©ï¼Œå®é™…åŠ è½½åœ¨æäº¤ä¸”å›¾ç‰‡å°±ç»ªåç»Ÿä¸€å¤„ç†
        });
        frontImageInput.addEventListener('change', function() {
            handleImagePreview(this, frontPreview);
        });
        
        backImageInput.addEventListener('change', function() {
            handleImagePreview(this, backPreview);
        });
        
        // å¤„ç†è¡¨å•æäº¤
        uploadForm.addEventListener('submit', function(e) {
            e.preventDefault();
            
            const frontFile = frontImageInput.files[0];
            const backFile = backImageInput.files[0];
            
            if (!frontFile || !backFile) {
                alert('è¯·é€‰æ‹©æ­£é¢å’ŒèƒŒé¢å›¾ç‰‡ï¼');
                return;
            }
            
            uploadBtn.disabled = true;
            uploadBtn.textContent = 'åˆ›å»ºä¸­...';
            
            // å¤„ç†å›¾ç‰‡å¹¶åˆ›å»ºçº¹ç†
            const frontReader = new FileReader();
            frontReader.onload = async function(e) {
                const frontImageData = e.target.result;
                frontTexture = createTexture(frontImageData, 0, false, false); // æ­£é¢çº¹ç†ç›´æ¥è´´å›¾ï¼Œæ— ç¿»è½¬
                
                const backReader = new FileReader();
                backReader.onload = async function(e) {
                    const backImageData = e.target.result;
                    backTexture = createTexture(backImageData, 0, false, false); // èƒŒé¢çº¹ç†ç›´æ¥è´´å›¾ï¼Œæ— ç¿»è½¬
                    backTextureOriginal = createTexture(backImageData, 0, false, false); // åŸå§‹èƒŒé¢çº¹ç†ï¼ˆç”¨äºè‡ªå®šä¹‰æ¨¡å‹ï¼‰
                    
                    // å¦‚æœé€‰æ‹©äº†è‡ªå®šä¹‰æ¨¡å‹ï¼Œåˆ™å…ˆè§£ææ¨¡å‹ï¼Œå†é™„åŠ æ­£/èƒŒé¢è´´å›¾å¹³é¢ï¼›
                    const modelFile = modelFileInput.files && modelFileInput.files[0];
                    if (modelFile) {
                        const reader = new FileReader();
                        reader.onload = function(ev) {
                            const arrayBuffer = ev.target.result;
                            gltfLoader.parse(arrayBuffer, '', function(gltf) {
                                if (cube) scene.remove(cube);
                                
                                // è®¡ç®—åŒ…å›´ç›’ï¼Œç¡®å®šæ¨¡å‹æœå‘
                                scene.add(gltf.scene);
                                const box = new THREE.Box3().setFromObject(gltf.scene);
                                const size = box.getSize(new THREE.Vector3());
                                scene.remove(gltf.scene);
                                
                                // åˆ¤æ–­æ¨¡å‹æœå‘ï¼šå¦‚æœYè½´æœ€çŸ­ï¼Œè¯´æ˜æ˜¯å¹³èººçš„ï¼Œéœ€è¦ç«–ç«‹
                                const dims = [
                                    { v: size.x, axis: 'x', idx: 0 },
                                    { v: size.y, axis: 'y', idx: 1 },
                                    { v: size.z, axis: 'z', idx: 2 }
                                ].sort((a,b)=>a.v-b.v); // ä»å°åˆ°å¤§æ’åº
                                const shortest = dims[0];
                                
                                // å¦‚æœYè½´æœ€çŸ­ï¼Œè¯´æ˜æ¨¡å‹æ˜¯å¹³èººçš„ï¼Œç»•Xè½´æ—‹è½¬-90åº¦ç«–ç«‹
                                if (shortest.idx === 1) {
                                    gltf.scene.rotation.x = -Math.PI / 2;
                                }
                                
                                // æ”¾å¤§æ¨¡å‹ä»¥ä¾¿æ›´å¥½åœ°æŸ¥çœ‹
                                const modelScale = 3.5; // æ”¾å¤§3.5å€
                                gltf.scene.scale.set(modelScale, modelScale, modelScale);
                                
                                // æ—‹è½¬å’Œç¼©æ”¾åé‡æ–°è®¡ç®—åŒ…å›´ç›’å¹¶å±…ä¸­
                                scene.add(gltf.scene);
                                const rotatedBox = new THREE.Box3().setFromObject(gltf.scene);
                                const rotatedCenter = rotatedBox.getCenter(new THREE.Vector3());
                                scene.remove(gltf.scene);
                                gltf.scene.position.sub(rotatedCenter);
                                
                                // åˆ›å»ºå®¹å™¨ç»„
                                cube = new THREE.Group();
                                
                                // ä¸ºæ¨¡å‹ä¸­çš„æ‰€æœ‰ç½‘æ ¼å¯ç”¨é˜´å½±å’Œé«˜è´¨é‡æè´¨
                                gltf.scene.traverse(function(child) {
                                    if (child.isMesh) {
                                        child.castShadow = true;
                                        child.receiveShadow = true;
                                        
                                        // å‡çº§æ‰€æœ‰æè´¨ä¸ºMeshStandardMaterialä»¥è·å¾—æ›´å¥½çš„å…‰ç…§æ•ˆæœ
                                        if (child.material) {
                                            const oldMaterial = child.material;
                                            
                                            // å¦‚æœæ˜¯BasicMaterialï¼Œå‡çº§ä¸ºStandardMaterial
                                            if (oldMaterial.isMeshBasicMaterial) {
                                                child.material = new THREE.MeshStandardMaterial({
                                                    map: oldMaterial.map,
                                                    color: oldMaterial.color,
                                                    transparent: oldMaterial.transparent,
                                                    opacity: oldMaterial.opacity,
                                                    side: oldMaterial.side,
                                                    metalness: 0.15,
                                                    roughness: 0.3,
                                                    envMapIntensity: 0.8
                                                });
                                            } 
                                            // å¦‚æœå·²ç»æ˜¯StandardMaterialï¼Œç¡®ä¿æœ‰æ­£ç¡®çš„å…‰ç…§å‚æ•°
                                            else if (oldMaterial.isMeshStandardMaterial) {
                                                oldMaterial.metalness = oldMaterial.metalness !== undefined ? oldMaterial.metalness : 0.15;
                                                oldMaterial.roughness = oldMaterial.roughness !== undefined ? oldMaterial.roughness : 0.3;
                                                oldMaterial.envMapIntensity = 0.8;
                                                oldMaterial.needsUpdate = true;
                                            }
                                        }
                                    }
                                });
                                
                                cube.add(gltf.scene);
                                scene.add(cube);
                                
                                // ä½¿ç”¨ä¹‹å‰è®¡ç®—çš„æ—‹è½¬ååŒ…å›´ç›’å°ºå¯¸
                                const rotatedSize = rotatedBox.getSize(new THREE.Vector3());
                                cube.userData.size = rotatedSize;
                                console.log('GLBæ¨¡å‹åŠ è½½å®Œæˆï¼Œæ—‹è½¬åå°ºå¯¸:', rotatedSize);
                                
                                // é™„åŠ æ­£/èƒŒé¢è´´å›¾å¹³é¢
                                createTexturedCube(frontImageData, backImageData).then(()=>{
                                    uploadBtn.disabled = false;
                                    uploadBtn.textContent = 'åˆ›å»º3Då¡ç‰‡';
                                    previewSection.style.display = 'block';
                                });
                            }, function(err){
                                console.error('æ¨¡å‹è§£æå¤±è´¥', err);
                                // å›é€€ä¸ºé»˜è®¤å¡ç‰‡
                                createTexturedCube(frontImageData, backImageData).then(()=>{
                                    uploadBtn.disabled = false;
                                    uploadBtn.textContent = 'åˆ›å»º3Då¡ç‰‡';
                                    previewSection.style.display = 'block';
                                });
                            });
                        };
                        reader.readAsArrayBuffer(modelFile);
                    } else {
                        // é»˜è®¤å¡ç‰‡è·¯å¾„
                        setTimeout(async () => {
                            await createTexturedCube(frontImageData, backImageData);
                            uploadBtn.disabled = false;
                            uploadBtn.textContent = 'åˆ›å»º3Då¡ç‰‡';
                            previewSection.style.display = 'block';
                        }, 300);
                    }
                };
                backReader.readAsDataURL(backFile);
            };
            frontReader.readAsDataURL(frontFile);
        });
        
        // æ§åˆ¶æŒ‰é’®äº‹ä»¶
        autoRotateBtn.addEventListener('click', function() {
            isAutoRotating = true;
            autoRotateBtn.classList.add('active');
            manualRotateBtn.classList.remove('active');
        });
        
        manualRotateBtn.addEventListener('click', function() {
            isAutoRotating = false;
            manualRotateBtn.classList.add('active');
            autoRotateBtn.classList.remove('active');
        });
        
        // é¼ æ ‡æ§åˆ¶
        canvas.addEventListener('mousemove', function(event) {
            if (!isAutoRotating) {
                const rect = canvas.getBoundingClientRect();
                mouseX = (event.clientX - rect.left) / rect.width;
                
                // æ§åˆ¶Yè½´æ—‹è½¬ï¼Œç«–ç«‹çš„å¡ç‰‡å·¦å³ç¿»è½¬
                targetRotationY = (mouseX - 0.5) * Math.PI * 2;
            }
        });
        
        // é¼ æ ‡æ»šè½®ç¼©æ”¾æ§åˆ¶
        canvas.addEventListener('wheel', function(event) {
            event.preventDefault();
            
            // è®¡ç®—ç¼©æ”¾å¢é‡
            const zoomSpeed = 0.5;
            const delta = event.deltaY > 0 ? zoomSpeed : -zoomSpeed;
            
            // æ›´æ–°ç›¸æœºè·ç¦»
            cameraDistance += delta;
            
            // é™åˆ¶è·ç¦»èŒƒå›´
            cameraDistance = Math.max(minDistance, Math.min(maxDistance, cameraDistance));
            
            // æ›´æ–°ç›¸æœºä½ç½®ï¼ˆç›¸æœºåœ¨Zè½´ï¼‰
            camera.position.z = cameraDistance;
        });
        
        // åˆå§‹åŒ–
        initThreeJS();
        
        // é»˜è®¤æ¿€æ´»è‡ªåŠ¨æ—‹è½¬
        autoRotateBtn.classList.add('active');
    </script>
</body>
</html>
